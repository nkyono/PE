'''
Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers and are generated by the following formulae:

Triangle	 	P3,n=n(n+1)/2	 	1, 3, 6, 10, 15, ...
Square	 	    P4,n=n2	 	        1, 4, 9, 16, 25, ...
Pentagonal	 	P5,n=n(3n−1)/2	 	1, 5, 12, 22, 35, ...
Hexagonal	 	P6,n=n(2n−1)	 	1, 6, 15, 28, 45, ...
Heptagonal	 	P7,n=n(5n−3)/2	 	1, 7, 18, 34, 55, ...
Octagonal	 	P8,n=n(3n−2)	 	1, 8, 21, 40, 65, ...
The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.

The set is cyclic, in that the last two digits of each number is the first two digits of the next number (including the last number with the first).
Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and pentagonal (P5,44=2882), 
is represented by a different number in the set.
This is the only set of 4-digit numbers with this property.
Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type: 
triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.
'''

# program outputs a bunch of 6 numbers, some of which aren't completely cyclic (doesn't come back around, more like a chain)
# going through there are multiple potential cycles but most are incorrect
# manually going through 8256 5625 2512 1281 8128 2882 is the correct cycle <-- fixed
def triNums(minLim, maxLim):
    nums = []
    x = 1
    while(True):
        num = int(x*(x+1)/2)
        if num < maxLim:
            if num > minLim:
                nums.append(num)
        else:
            break
        x = x + 1
    return nums

def sqrNums(minLim, maxLim):
    nums = []
    x = 1
    while(True):
        num = int(x*x)
        if num < maxLim:
            if num > minLim:
                nums.append(num)
        else:
            break
        x = x + 1
    return nums
    
def pentNums(minLim, maxLim):
    nums = []
    x = 1
    while(True):
        num = int(x*(3*x-1)/2)
        if num < maxLim:
            if num > minLim:
                nums.append(num)
        else:
            break
        x = x + 1
    return nums

def hexNums(minLim, maxLim):
    nums = []
    x = 1
    while(True):
        num = int(x*(2*x-1))
        if num < maxLim:
            if num > minLim:
                nums.append(num)
        else:
            break
        x = x + 1
    return nums

def heptNums(minLim, maxLim):
    nums = []
    x = 1
    while(True):
        num = int(x*(5*x-3)/2)
        if num < maxLim:
            if num > minLim:
                nums.append(num)
        else:
            break
        x = x + 1
    return nums

def octNums(minLim, maxLim):
    nums = []
    x = 1
    while(True):
        num = int(x*(3*x-2))
        if num < maxLim:
            if num > minLim:
                nums.append(num)
        else:
            break
        x = x + 1
    return nums

def checkFor(key, numType, nums, toCheck, ans, first):
    found = False
    if numType == -1:
        # print(ans)
        if ans[-2:] == first:
            print("match:",ans)
            return True, ans
        return False, ""
    if key in nums[numType]:
        for a in nums[numType][key]:
            if len(toCheck) > 0:
                for x in toCheck:
                    nextCheck = toCheck[:]
                    nextCheck.remove(x)
                    test, newAns = checkFor(a, x, nums, nextCheck, ans + ' ' + key + a, first)
                    if test:
                        return test,newAns
            else:
                test, newAns = checkFor(a, -1, nums, toCheck, ans + ' ' + key + a, first)
                if test:
                    return test,newAns
    return found, ""

def transformNums(numSet):
    nSet = {}
    for x in numSet:
        xstr = str(x)
        if xstr[:2] in nSet:
            nSet[xstr[:2]].append(xstr[2:])
        else:
            nSet[xstr[:2]] = [xstr[2:]]
    return nSet

def getSets():
    minLim, maxLim = 1000,10000
    nums = []
    nums.append(triNums(minLim, maxLim))
    nums.append(sqrNums(minLim, maxLim))
    nums.append(pentNums(minLim, maxLim))
    nums.append(hexNums(minLim, maxLim))
    nums.append(heptNums(minLim, maxLim))
    nums.append(octNums(minLim, maxLim))

    transNums = []
    for x in nums:
        transNums.append(transformNums(x))

    for a in transNums[0]:
        for b in transNums[0][a]:
            toCheck = [1,2,3,4,5]
            # print(a,b)
            for c in toCheck:
                nextCheck = toCheck[:]
                nextCheck.remove(c)
                test, ans = checkFor(b, c, transNums,nextCheck, a+b, a)
                if test:
                    print(ans)

def main():
    getSets()

if __name__ == '__main__':
    import time
    start = time.time()
    main()
    print("time:",time.time()-start)